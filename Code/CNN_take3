import matplotlib as plt
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torch.utils.data import Dataset
from torchvision.transforms import ToTensor
import pandas as pd
import numpy as np
import csv
import glob
import scipy.io as sio
import os
import torch.nn.functional as F


class TestDataSet(Dataset):
    def __init__(self):
        self.files = glob.glob(r"C:\Users\Jakob\Desktop\AAU\7Semester\Projekt\P7_projekt\DATA\ON_3\*.mat")
        
    def __getitem__(self, idx):
        self.data_path = os.path.join(self.files[idx])
        self.dataset = sio.loadmat(self.data_path)
        self.label = self.dataset['ic_clean']['trialinfo'][0][0][idx]
        temp = []
        for i in self.label[18:]:
            temp.append(chr(i))
        temp = "".join(temp)
        if temp.find('Male') < temp.find('Female'):
            self.label = torch.zeros(1)
        else:
            self.label = torch.ones(1)
        self.dataset = self.dataset['ic_clean']['trial'][0][0][0][idx]
        self.dataset = self.dataset[:-2, :]
        return self.dataset, self.label
    
    def __len__(self):
        return 20


class CNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Sequential(
        nn.Conv1d(64, 64, 5, 2),
        nn.MaxPool1d(2, 2)
        )
        self.conv2 = nn.Sequential(
            nn.Conv1d(64, 64, 5, 2),
            nn.MaxPool1d(2,2)
        )
        self.conv3 = nn.Sequential(
            nn.Conv1d(64, 64, 5, 2),
            nn.MaxPool1d(2,2)
        )
        self.fc1 = nn.Sequential(
            nn.Linear(20928 , 5232),
            nn.ReLU()
        )
        self.fc2 = nn.Sequential(
            nn.Linear(5232, 1308),
            nn.ReLU()
        )
        self.fc3 = nn.Sequential(
            nn.Linear(1308, 1),
            nn.ReLU()
        )
    def forward(self, x):
        x = self.conv1(x)
        x = self.conv2(x)
        x = self.conv3(x)
        x = torch.flatten(x)
        x = self.fc1(x)
        x = self.fc2(x)
        x = self.fc3(x)
        x = F.sigmoid(x)
        return x
runnacc = 0
training_data = TestDataSet()
train_dataloader = DataLoader(training_data, batch_size=1, shuffle=True)
device = 'cuda' if torch.cuda.is_available() else 'cpu'
model = CNN().to(device)
loss_fn = nn.BCELoss()
optimizer = torch.optim.Adam(model.parameters(), lr= 0.001)
epochs = 5
for e in range(0, epochs):

    model.train()
    total_loss = 0
    # initialize the total training and validation loss
    totalTrainLoss = 0
    totalValLoss = 0
	# initialize the number of correct predictions in the training
	# and validation step
    trainCorrect = 0
    valCorrect = 0
    
    for (x, y) in train_dataloader:
        x = x.float().to(device)
        print(x)
        y = torch.squeeze(y, 1).to(device)
        output = model(x)
        loss = loss_fn(output, y)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        total_loss += loss
        acc = (output.round() == y).float().mean()
        runnacc += acc
        # trainCorrect += (output.argmax(1) == y)
        # print(acc)


print(runnacc)